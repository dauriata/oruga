{"version":3,"file":"defineClasses-uo4lMA-t.mjs","sources":["../../src/composables/defineClasses.ts"],"sourcesContent":["import {\r\n    ref,\r\n    watch,\r\n    isRef,\r\n    toValue,\r\n    getCurrentInstance,\r\n    effectScope,\r\n    onScopeDispose,\r\n    getCurrentScope,\r\n    type MaybeRefOrGetter,\r\n    type Ref,\r\n    type ComponentInternalInstance,\r\n} from \"vue\";\r\n\r\nimport { getOptions } from \"@/utils/config\";\r\nimport { isDefined, blankIfUndefined, getValueByPath } from \"@/utils/helpers\";\r\n\r\nimport type {\r\n    ClassBind,\r\n    ClassDefinition,\r\n    ComponentProps,\r\n    TransformFunction,\r\n} from \"@/types\";\r\n\r\n// named tuple as prop definition\r\ntype ComputedClass = readonly [\r\n    className: string,\r\n    defaultClass: string,\r\n    suffix?: MaybeRefOrGetter<string>,\r\n    apply?: MaybeRefOrGetter<boolean>,\r\n];\r\n\r\n/** Helperfunction to get all active classes from a class binding list */\r\nexport const getActiveClasses = (classes: ClassBind[]): string[] => {\r\n    if (!classes) return [];\r\n    return classes.flatMap((bind) =>\r\n        Object.keys(bind).filter((key) => key && bind[key]),\r\n    );\r\n};\r\n\r\n/**\r\n * Calculate dynamic classes based on class definitions\r\n */\r\nexport function defineClasses(\r\n    ...classDefinitions: ComputedClass[]\r\n): Ref<ClassBind[]> {\r\n    // getting a hold of the internal instance of the component in setup()\r\n    const vm = getCurrentInstance();\r\n    if (!vm)\r\n        throw new Error(\r\n            \"defineClasses must be called within a component setup function.\",\r\n        );\r\n\r\n    // create an effect scope object to capture reactive effects\r\n    const scope = effectScope();\r\n\r\n    // reactive classes container\r\n    const classes = ref<ClassBind[]>([]);\r\n\r\n    classes.value = classDefinitions.map((defintion, index) => {\r\n        const className = defintion[0];\r\n        const defaultClass = defintion[1];\r\n        const suffix = defintion[2];\r\n        const apply = defintion[3];\r\n\r\n        function getClassBind(): ClassBind {\r\n            // compute class based on definition parameter\r\n            const computedClass = computeClass(\r\n                vm,\r\n                className,\r\n                defaultClass,\r\n                toValue(suffix),\r\n            );\r\n\r\n            // if apply is not defined or true\r\n            const applied = !isDefined(apply) || toValue(apply);\r\n\r\n            // return class bind property\r\n            return { [computedClass]: applied };\r\n        }\r\n\r\n        // if suffix is defined, watch suffix changed and recalculate class\r\n        if (isDefined(suffix) && isRef(suffix)) {\r\n            scope.run(() => {\r\n                watch(\r\n                    () => toValue(suffix),\r\n                    (value, oldValue) => {\r\n                        // only recompute when value has really changed\r\n                        if (value === oldValue) return;\r\n                        // recompute the class bind property\r\n                        const classBind = getClassBind();\r\n                        // update class binding property by class index\r\n                        classes.value[index] = classBind;\r\n                    },\r\n                );\r\n            });\r\n        }\r\n\r\n        // if apply is defined, watch apply changed and update apply state (no need of recalculation here)\r\n        if (isDefined(apply) && isRef(apply)) {\r\n            scope.run(() => {\r\n                watch(\r\n                    () => toValue(apply),\r\n                    (applied, oldValue) => {\r\n                        // only change apply when value has really changed\r\n                        if (applied === oldValue) return;\r\n\r\n                        // get class binding property by class index\r\n                        const classBind = classes.value[index];\r\n\r\n                        // update the apply class binding state\r\n                        Object.keys(classBind).forEach(\r\n                            (key) => (classBind[key] = applied),\r\n                        );\r\n\r\n                        // update the class binding property by class index\r\n                        classes.value[index] = classBind;\r\n                    },\r\n                );\r\n            });\r\n        }\r\n\r\n        // return computed class based on parameter\r\n        return getClassBind();\r\n    });\r\n\r\n    // check if there is a current active effect scope\r\n    if (getCurrentScope())\r\n        // Registers a dispose callback on the current active effect scope.\r\n        // The callback will be invoked when the associated effect scope is stopped.\r\n        onScopeDispose(() => {\r\n            // stop all effects when appropriate\r\n            if (scope) scope.stop();\r\n        });\r\n\r\n    // return reactive classes\r\n    return classes;\r\n}\r\n\r\n/**\r\n * Compute a class by a field name\r\n */\r\nfunction computeClass(\r\n    vm: ComponentInternalInstance,\r\n    field: string,\r\n    defaultValue?: string,\r\n    suffix = \"\",\r\n): string {\r\n    // get component props\r\n    const props = vm.props;\r\n\r\n    const configField = vm.proxy?.$options.configField;\r\n    if (!configField)\r\n        throw new Error(\"component must define the 'configField' option.\");\r\n\r\n    // get component instance override property\r\n    const config = props.override === true ? {} : getOptions();\r\n\r\n    // get global config override property\r\n    const globalOverride =\r\n        props.override || getValueByPath(config, \"override\", false);\r\n    // get component config override property\r\n    const localOverride = getValueByPath(\r\n        config,\r\n        `${configField}.override`,\r\n        globalOverride,\r\n    );\r\n    // get field specific config override property\r\n    const overrideClass = getValueByPath(\r\n        config,\r\n        `${configField}.${field}.override`,\r\n        localOverride,\r\n    );\r\n\r\n    // get global tranform class\r\n    const globalTransformClasses = getValueByPath<TransformFunction>(\r\n        config,\r\n        \"transformClasses\",\r\n        undefined,\r\n    );\r\n    // get field specific tranform class\r\n    const localTransformClasses = getValueByPath<TransformFunction>(\r\n        config,\r\n        `${configField}.transformClasses`,\r\n        undefined,\r\n    );\r\n\r\n    // get config class definition\r\n    let globalClass =\r\n        getValueByPath<ClassDefinition>(\r\n            config,\r\n            `${configField}.${field}.class`,\r\n            \"\",\r\n        ) ||\r\n        getValueByPath<ClassDefinition>(config, `${configField}.${field}`, \"\");\r\n    // get instance class override\r\n    let currentClass = getValueByPath<ClassDefinition>(props, field, \"\");\r\n\r\n    // procsess instance class\r\n    if (Array.isArray(currentClass)) {\r\n        currentClass = currentClass.join(\" \");\r\n    }\r\n    if (typeof currentClass === \"function\") {\r\n        const props = getProps(vm);\r\n        currentClass = currentClass(suffix, props);\r\n    } else {\r\n        currentClass = suffixProcessor(currentClass as string, suffix);\r\n    }\r\n\r\n    // process confic class\r\n    if (Array.isArray(globalClass)) {\r\n        globalClass = globalClass.join(\" \");\r\n    }\r\n    if (typeof globalClass === \"function\") {\r\n        const props = getProps(vm);\r\n        globalClass = globalClass(suffix, props);\r\n    } else {\r\n        globalClass = suffixProcessor(globalClass as string, suffix);\r\n    }\r\n\r\n    // process default value\r\n    if (defaultValue.includes(\"{*}\")) {\r\n        defaultValue = defaultValue.replace(\r\n            /\\{\\*\\}/g,\r\n            blankIfUndefined(suffix),\r\n        );\r\n    } else {\r\n        defaultValue = defaultValue + blankIfUndefined(suffix);\r\n    }\r\n\r\n    // if override is false add default value\r\n    // add global config classes\r\n    // add instance classes\r\n    let appliedClasses = (\r\n        `${!overrideClass ? defaultValue : \"\"} ` +\r\n        `${blankIfUndefined(globalClass)} ` +\r\n        `${blankIfUndefined(currentClass)}`\r\n    )\r\n        .trim()\r\n        .replace(/\\s\\s+/g, \" \");\r\n\r\n    // apply component local transformclass if available\r\n    if (localTransformClasses) {\r\n        appliedClasses = localTransformClasses(appliedClasses);\r\n    }\r\n    // else apply global transformclass if available\r\n    else if (globalTransformClasses) {\r\n        appliedClasses = globalTransformClasses(appliedClasses);\r\n    }\r\n\r\n    return appliedClasses;\r\n}\r\n\r\nfunction suffixProcessor(input: string, suffix: string): string {\r\n    return blankIfUndefined(input)\r\n        .split(\" \")\r\n        .filter((cls) => cls.length > 0)\r\n        .map((cls) => cls + blankIfUndefined(suffix))\r\n        .join(\" \");\r\n}\r\n\r\nconst getProps = (vm: ComponentInternalInstance): ComponentProps => {\r\n    let props = vm.proxy.$props;\r\n\r\n    // get all props which ends with \"Props\", these are compressed parent props\r\n    // append these parent props as root level prop\r\n    Object.keys(props)\r\n        .filter((key) => key.endsWith(\"Props\"))\r\n        .forEach((key) => (props = { ...props, ...props[key] }));\r\n\r\n    // TODO: revert object escape\r\n    return { props };\r\n};\r\n"],"names":["props"],"mappings":"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"}