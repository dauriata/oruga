{"version":3,"file":"useProgrammatic-CV--sv7g.cjs","sources":["../../src/composables/useProgrammatic.ts"],"sourcesContent":["import { computed, getCurrentInstance, onMounted, type Ref } from \"vue\";\r\nimport type { ProgrammaticInstance } from \"..\";\r\nimport { isClient, HTMLElement } from \"@/utils/ssr\";\r\nimport { usePropBinding } from \"./usePropValue\";\r\nimport { useEventListener } from \"./useEventListener\";\r\nimport { removeElement } from \"@/utils/helpers\";\r\n\r\ntype ProgrammaticProps = {\r\n    active: boolean;\r\n    /** Define if the component is cancelable at all or by specific events. */\r\n    cancelable?: boolean | string[];\r\n    /** Callback function to call after user canceled (pressed escape / clicked outside). */\r\n    onCancel: (...args: any[]) => void;\r\n    /** Callback function to call after close (programmatically close or user canceled). */\r\n    onClose: (...args: any[]) => void;\r\n    /** DOM element where the programmatic component will be mounted on. */\r\n    container?: string | HTMLElement;\r\n    /** This defines the programmatic usage. */\r\n    programmatic?: ProgrammaticInstance;\r\n};\r\n\r\nexport interface ProgrammaticOptions {\r\n    /** Method options that allow the component to be cancelled. */\r\n    cancelOptions?: string[];\r\n    /** Destroy the component on hide. Default is `true`. */\r\n    destroyOnHide?: boolean;\r\n}\r\n\r\n/**\r\n * This provides functionalities for programmatic usage.\r\n * The component get appended to the container.\r\n * This defines a cancel and close handler, as well as escape handler.\r\n * The component will be distroyed on close.\r\n * @param elementRef HTMLElement which should injected\r\n * @param props ProgrammaticProps\r\n * @param emits [\"update:active\", \"close\"]\r\n * @param options\r\n */\r\nexport function useProgrammaticComponent(\r\n    elementRef: Ref<HTMLElement> | (() => HTMLElement),\r\n    props: ProgrammaticProps,\r\n    emits: {\r\n        (e: \"update:active\", value: boolean): void;\r\n        (e: \"close\", ...args: any[]): void;\r\n    },\r\n    options: ProgrammaticOptions = { cancelOptions: [\"escape\", \"outside\"] },\r\n) {\r\n    // getting a hold of the internal instance in setup()\r\n    const vm = getCurrentInstance();\r\n    if (!vm)\r\n        throw new Error(\r\n            \"useProgrammaticComponent must be called within a component setup function.\",\r\n        );\r\n\r\n    const isActive = usePropBinding(\"active\", props, emits);\r\n\r\n    const cancelOptions = computed(() =>\r\n        typeof props.cancelable === \"boolean\"\r\n            ? props.cancelable\r\n                ? options.cancelOptions\r\n                : []\r\n            : props.cancelable,\r\n    );\r\n\r\n    function getElement(): HTMLElement {\r\n        return typeof elementRef === \"function\"\r\n            ? elementRef()\r\n            : elementRef.value;\r\n    }\r\n\r\n    const container = computed(\r\n        (): HTMLElement =>\r\n            typeof props.container === \"string\"\r\n                ? document.querySelector<HTMLElement>(props.container)\r\n                : (props.container as HTMLElement) || document.body,\r\n    );\r\n\r\n    onMounted(() => {\r\n        if (props.programmatic) {\r\n            if (props.programmatic.instances) {\r\n                props.programmatic.instances.add(vm);\r\n            }\r\n            // Insert the component in the container or the body tag\r\n            // only if it's programmatic\r\n            const el = getElement();\r\n            container.value.appendChild(el);\r\n\r\n            isActive.value = true;\r\n        }\r\n    });\r\n\r\n    if (isClient) useEventListener(\"keyup\", onKeyPress, container.value);\r\n\r\n    /** Keypress event that is bound to the document. */\r\n    function onKeyPress(event: KeyboardEvent): void {\r\n        if (isActive.value && (event.key === \"Escape\" || event.key === \"Esc\")) {\r\n            cancel(\"escape\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close the component if cancelable.\r\n     * @param method Cancel method\r\n     */\r\n    function cancel(method: string): void {\r\n        if (!props.cancelable || !isActive.value) return;\r\n        // check if method is in options\r\n        if (cancelOptions.value.indexOf(method) < 0) return;\r\n        props.onCancel.apply(null);\r\n        close({ action: \"cancel\", method });\r\n    }\r\n\r\n    /**\r\n     * Emit events, and destroy the component if it's programmatic.\r\n     * Can get called outside of a setup scope.\r\n     */\r\n    function close(...args: any[]): void {\r\n        vm.emit(\"close\");\r\n        props.onClose.apply(null, args);\r\n\r\n        if (props.programmatic) {\r\n            if (props.programmatic.instances)\r\n                props.programmatic.instances.remove(vm);\r\n\r\n            if (props.programmatic.resolve)\r\n                props.programmatic.resolve.apply(null, args);\r\n\r\n            // Timeout for the animation complete before destroying\r\n            setTimeout(() => {\r\n                // set active state of current instance\r\n                vm.props.active = false;\r\n                vm.emit(\"update:active\", false);\r\n                if (\r\n                    typeof options.destroyOnHide === \"undefined\" ||\r\n                    options.destroyOnHide\r\n                )\r\n                    if (isClient)\r\n                        window.requestAnimationFrame(() => {\r\n                            // remove the component from the container or the body tag\r\n                            const el = getElement();\r\n                            if (el) removeElement(el);\r\n                        });\r\n                    else {\r\n                        const el = getElement();\r\n                        if (el) removeElement(el);\r\n                    }\r\n            });\r\n        } else {\r\n            // set active state of current instance\r\n            vm.props.active = false;\r\n            vm.emit(\"update:active\", false);\r\n        }\r\n    }\r\n\r\n    return { close, cancel, isActive, container };\r\n}\r\n"],"names":["getCurrentInstance","usePropBinding","computed","onMounted","isClient","useEventListener","removeElement"],"mappings":";;;;;;;AAsCgB,SAAA,yBACZ,YACA,OACA,OAIA,UAA+B,EAAE,eAAe,CAAC,UAAU,SAAS,KACtE;AAEE,QAAM,KAAKA,IAAAA;AACX,MAAI,CAAC;AACD,UAAM,IAAI;AAAA,MACN;AAAA,IAAA;AAGR,QAAM,WAAWC,aAAA,eAAe,UAAU,OAAO,KAAK;AAEtD,QAAM,gBAAgBC,IAAA;AAAA,IAAS,MAC3B,OAAO,MAAM,eAAe,YACtB,MAAM,aACF,QAAQ,gBACR,KACJ,MAAM;AAAA,EAAA;AAGhB,WAAS,aAA0B;AAC/B,WAAO,OAAO,eAAe,aACvB,WAAA,IACA,WAAW;AAAA,EACrB;AAEA,QAAM,YAAYA,IAAA;AAAA,IACd,MACI,OAAO,MAAM,cAAc,WACrB,SAAS,cAA2B,MAAM,SAAS,IAClD,MAAM,aAA6B,SAAS;AAAA,EAAA;AAG3DC,MAAAA,UAAU,MAAM;AACZ,QAAI,MAAM,cAAc;AAChB,UAAA,MAAM,aAAa,WAAW;AACxB,cAAA,aAAa,UAAU,IAAI,EAAE;AAAA,MACvC;AAGA,YAAM,KAAK;AACD,gBAAA,MAAM,YAAY,EAAE;AAE9B,eAAS,QAAQ;AAAA,IACrB;AAAA,EAAA,CACH;AAEG,MAAAC,IAAA;AAA2BC,qBAAAA,iBAAA,SAAS,YAAY,UAAU,KAAK;AAGnE,WAAS,WAAW,OAA4B;AAC5C,QAAI,SAAS,UAAU,MAAM,QAAQ,YAAY,MAAM,QAAQ,QAAQ;AACnE,aAAO,QAAQ;AAAA,IACnB;AAAA,EACJ;AAMA,WAAS,OAAO,QAAsB;AAClC,QAAI,CAAC,MAAM,cAAc,CAAC,SAAS;AAAO;AAE1C,QAAI,cAAc,MAAM,QAAQ,MAAM,IAAI;AAAG;AACvC,UAAA,SAAS,MAAM,IAAI;AACzB,UAAM,EAAE,QAAQ,UAAU,OAAQ,CAAA;AAAA,EACtC;AAMA,WAAS,SAAS,MAAmB;AACjC,OAAG,KAAK,OAAO;AACT,UAAA,QAAQ,MAAM,MAAM,IAAI;AAE9B,QAAI,MAAM,cAAc;AACpB,UAAI,MAAM,aAAa;AACb,cAAA,aAAa,UAAU,OAAO,EAAE;AAE1C,UAAI,MAAM,aAAa;AACnB,cAAM,aAAa,QAAQ,MAAM,MAAM,IAAI;AAG/C,iBAAW,MAAM;AAEb,WAAG,MAAM,SAAS;AACf,WAAA,KAAK,iBAAiB,KAAK;AAC9B,YACI,OAAO,QAAQ,kBAAkB,eACjC,QAAQ;AAEJ,cAAAD,IAAA;AACA,mBAAO,sBAAsB,MAAM;AAE/B,oBAAM,KAAK;AACP,kBAAA;AAAIE,wBAAA,cAAc,EAAE;AAAA,YAAA,CAC3B;AAAA,eACA;AACD,kBAAM,KAAK;AACP,gBAAA;AAAIA,sBAAA,cAAc,EAAE;AAAA,UAC5B;AAAA,MAAA,CACP;AAAA,IAAA,OACE;AAEH,SAAG,MAAM,SAAS;AACf,SAAA,KAAK,iBAAiB,KAAK;AAAA,IAClC;AAAA,EACJ;AAEA,SAAO,EAAE,OAAO,QAAQ,UAAU,UAAU;AAChD;;"}